<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Sorting Algorithms</title>
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;500&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="Styles.css">
</head>

<body>
    <div id="sidebar">
        <ul>
            <li><a href="index.html">Home</a></li>
            <li><a href="Arrays.html">Arrays</a></li>
            <li><a href="List.html">List</a></li>
            <li><a href="LinkedList.html">LinkedList</a></li>
            <li><a href="Strings.html">Strings</a></li>
            <li><a href="Regex.html">Regular Expressions</a></li>
            <li><a href="Algorithms.html">Common Code</a></li>
            <li><a href="Dictionaries.html">Dictionaries</a></li>
            <li><a href="Sets.html">Hash Sets</a></li>
            <li><a href="Queue.html">Queues</a></li>
            <li><a href="Stack.html">Stacks</a></li>
             <li><a href="Sorting.html">Sorting</a></li>
        </ul>
    </div>
    <div id="content">
        <section id="Sorting-section">
            <h2>Sorting Algorithms</h2>
            
            <div>
                <h3>Bubble Sort</h3>
                <p>Bubble sort repeatedly steps through the list, compares adjacent elements, and swaps them if they are in the wrong order. The process is repeated until the list is sorted.</p>
                <pre><code class="language-csharp">
public void BubbleSort(int[] arr) {
    int n = arr.Length;
    for (int i = 0; i < n - 1; i++) {
        for (int j = 0; j < n - i - 1; j++) {
            if (arr[j] > arr[j + 1]) {
                // Swap arr[j] and arr[j+1]
                int temp = arr[j];
                arr[j] = arr[j + 1];
                arr[j + 1] = temp;
            }
        }
    }
}
                </code></pre>
            </div>
            
            <div>
                <h3>Selection Sort</h3>
                <p>Selection sort divides the input list into two parts: a sorted sublist and an unsorted sublist. Initially, the sorted sublist is empty, and the unsorted sublist is the entire list. The algorithm selects the smallest element from the unsorted sublist and moves it to the end of the sorted sublist. This process is repeated until the unsorted sublist becomes empty.</p>
                <pre><code class="language-csharp">
public void SelectionSort(int[] arr) {
    int n = arr.Length;
    for (int i = 0; i < n - 1; i++) {
        int minIndex = i;
        for (int j = i + 1; j < n; j++) {
            if (arr[j] < arr[minIndex]) {
                minIndex = j;
            }
        }
        // Swap arr[i] and arr[minIndex]
        int temp = arr[i];
        arr[i] = arr[minIndex];
        arr[minIndex] = temp;
    }
}
                </code></pre>
            </div>
            
            <div>
                <h3>Insertion Sort</h3>
                <p>Insertion sort builds the final sorted list one item at a time. It iterates over each element in the list, removing it from the unsorted portion of the list and inserting it into its correct position in the sorted portion.</p>
                <pre><code class="language-csharp">
public void InsertionSort(int[] arr) {
    int n = arr.Length;
    for (int i = 1; i < n; i++) {
        int key = arr[i];
        int j = i - 1;
        while (j >= 0 && arr[j] > key) {
            arr[j + 1] = arr[j];
            j = j - 1;
        }
        arr[j + 1] = key;
    }
}
                </code></pre>
            </div>
            
           <div>
    <h3>Merge Sort</h3>
    <p>Merge sort is a divide-and-conquer algorithm that divides the input list into two halves, recursively sorts each half, and then merges the sorted halves to produce a single sorted list.</p>
    <pre><code class="language-csharp">
public void MergeSort(int[] arr) {
    if (arr.Length <= 1)
        return;

    int mid = arr.Length / 2;
    int[] left = new int[mid];
    int[] right = new int[arr.Length - mid];

    Array.Copy(arr, 0, left, 0, mid);
    Array.Copy(arr, mid, right, 0, arr.Length - mid);

    MergeSort(left);
    MergeSort(right);
    Merge(arr, left, right);
}

private void Merge(int[] arr, int[] left, int[] right) {
    int i = 0, j = 0, k = 0;

    while (i < left.Length && j < right.Length) {
        if (left[i] <= right[j]) {
            arr[k++] = left[i++];
        } else {
            arr[k++] = right[j++];
        }
    }

    while (i < left.Length)
        arr[k++] = left[i++];

    while (j < right.Length)
        arr[k++] = right[j++];
}
    </code></pre>
</div>

<div>
    <h3>Quick Sort</h3>
    <p>Quick sort is another divide-and-conquer algorithm that selects a pivot element and partitions the input list into two sublists: elements less than the pivot and elements greater than the pivot. It then recursively sorts each sublist.</p>
    <pre><code class="language-csharp">
public void QuickSort(int[] arr, int low, int high) {
    if (low < high) {
        int partitionIndex = Partition(arr, low, high);

        QuickSort(arr, low, partitionIndex - 1);
        QuickSort(arr, partitionIndex + 1, high);
    }
}

private int Partition(int[] arr, int low, int high) {
    int pivot = arr[high];
    int i = low - 1;

    for (int j = low; j < high; j++) {
        if (arr[j] < pivot) {
            i++;

            int temp = arr[i];
            arr[i] = arr[j];
            arr[j] = temp;
        }
    }

    int temp1 = arr[i + 1];
    arr[i + 1] = arr[high];
    arr[high] = temp1;

    return i + 1;
}
    </code></pre>
</div>

<div>
    <h3>Heap Sort</h3>
    <p>Heap sort is based on the heap data structure. It first builds a max heap from the input list, then repeatedly extracts the maximum element from the heap and rebuilds the heap until the list is sorted.</p>
    <pre><code class="language-csharp">
public void HeapSort(int[] arr) {
    int n = arr.Length;

    // Build heap (rearrange array)
    for (int i = n / 2 - 1; i >= 0; i--) {
        Heapify(arr, n, i);
    }

    // One by one extract an element from heap
    for (int i = n - 1; i > 0; i--) {
        // Move current root to end
        int temp = arr[0];
        arr[0] = arr[i];
        arr[i] = temp;

        // call max heapify on the reduced heap
        Heapify(arr, i, 0);
    }
}

private void Heapify(int[] arr, int n, int i) {
    int largest = i; // Initialize largest as root
    int l = 2 * i + 1; // left = 2*i + 1
    int r = 2 * i + 2; // right = 2*i + 2

    // If left child is larger than root
    if (l < n && arr[l] > arr[largest])
        largest = l;

    // If right child is larger than largest so far
    if (r < n && arr[r] > arr[largest])
        largest = r;

    // If largest is not root
    if (largest != i) {
        int swap = arr[i];
        arr[i] = arr[largest];
        arr[largest] = swap;

        // Recursively heapify the affected sub-tree
        Heapify(arr, n, largest);
    }
}
    </code></pre>
</div>

<div>
    <h3>Counting Sort</h3>
    <p>Counting sort is a non-comparison-based sorting algorithm that operates by counting the frequency of each distinct element in the input list and then using arithmetic to determine the position of each element in the sorted output list.</p>
    <pre><code class="language-csharp">
public void CountingSort(int[] arr) {
    int n = arr.Length;
    int max = arr[0];
    for (int i = 1; i < n; i++) {
        if (arr[i] > max)
            max = arr[i];
    }

    int[] count = new int[max + 1];

    for (int i = 0; i < n; i++) {
        count[arr[i]]++;
    }

    int outputIndex = 0;
    for (int i = 0; i <= max; i++) {
        for (int j = 0; j < count[i]; j++) {
            arr[outputIndex++] = i;
        }
    }
}
    </code></pre>
</div>

<div>
    <h3>Radix Sort</h3>
    <p>Radix sort is a non-comparison-based sorting algorithm that sorts elements by their individual digits. It sorts the elements by first grouping the individual digits of the same place value together and then sorting the elements according to their increasing/decreasing order of place values.</p>
    <pre><code class="language-csharp">
public void RadixSort(int[] arr) {
    int n = arr.Length;
    int max = arr[0];
    for (int i = 1; i < n; i++) {
        if (arr[i] > max)
            max = arr[i];
    }

    for (int exp = 1; max / exp > 0; exp *= 10) {
        CountingSortByDigit(arr, n, exp);
    }
}

private void CountingSortByDigit(int[] arr, int n, int exp) {
    int[] output = new int[n];
    int[] count = new int[10];

    for (int i = 0; i < n; i++) {
        count[(arr[i] / exp) % 10]++;
    }

    for (int i = 1; i < 10; i++) {
        count[i] += count[i - 1];
    }

    for (int i = n - 1; i >= 0; i--) {
        output[count[(arr[i] / 

        </section>
    

    <div>
    <h3>Depth-First Search (DFS)</h3>
    <p>Depth-First Search (DFS) is a graph traversal algorithm that explores as far as possible along each branch before backtracking. It uses a stack data structure to keep track of vertices to visit.</p>
    <pre><code class="language-csharp">
using System;
using System.Collections.Generic;

public class Graph {
    private int V; // Number of vertices
    private List<int>[] adj; // Adjacency list

    public Graph(int v) {
        V = v;
        adj = new List<int>[v];
        for (int i = 0; i < v; ++i) {
            adj[i] = new List<int>();
        }
    }

    public void AddEdge(int v, int w) {
        adj[v].Add(w);
    }

    public void DFSUtil(int v, bool[] visited) {
        visited[v] = true;
        Console.Write(v + " ");

        foreach (int i in adj[v]) {
            if (!visited[i]) {
                DFSUtil(i, visited);
            }
        }
    }

    public void DFS(int v) {
        bool[] visited = new bool[V];
        DFSUtil(v, visited);
    }
}

class Program {
    static void Main(string[] args) {
        Graph g = new Graph(4);
        g.AddEdge(0, 1);
        g.AddEdge(0, 2);
        g.AddEdge(1, 2);
        g.AddEdge(2, 0);
        g.AddEdge(2, 3);
        g.AddEdge(3, 3);

        Console.WriteLine("Depth-First Traversal starting from vertex 2:");
        g.DFS(2); // Output: 2 0 1 3
    }
}
    </code></pre>
</div>

<div>
    <h3>Breadth-First Search (BFS)</h3>
    <p>Breadth-First Search (BFS) is a graph traversal algorithm that explores all the neighbor nodes at the present depth prior to moving on to the nodes at the next depth level. It uses a queue data structure to keep track of vertices to visit.</p>
    <pre><code class="language-csharp">
using System;
using System.Collections.Generic;

public class Graph {
    private int V; // Number of vertices
    private List<int>[] adj; // Adjacency list

    public Graph(int v) {
        V = v;
        adj = new List<int>[v];
        for (int i = 0; i < v; ++i) {
            adj[i] = new List<int>();
        }
    }

    public void AddEdge(int v, int w) {
        adj[v].Add(w);
    }

    public void BFS(int s) {
        bool[] visited = new bool[V];
        Queue<int> queue = new Queue<int>();

        visited[s] = true;
        queue.Enqueue(s);

        while (queue.Count != 0) {
            s = queue.Dequeue();
            Console.Write(s + " ");

            foreach (int i in adj[s]) {
                if (!visited[i]) {
                    visited[i] = true;
                    queue.Enqueue(i);
                }
            }
        }
    }
}

class Program {
    static void Main(string[] args) {
        Graph g = new Graph(4);
        g.AddEdge(0, 1);
        g.AddEdge(0, 2);
        g.AddEdge(1, 2);
        g.AddEdge(2, 0);
        g.AddEdge(2, 3);
        g.AddEdge(3, 3);

        Console.WriteLine("Breadth-First Traversal starting from vertex 2:");
        g.BFS(2); // Output: 2 0 3 1
    }
}
    </code></pre>
</div>

<div>
    <h3>Dijkstra's Algorithm</h3>
    <p>Dijkstra's algorithm is a graph search algorithm that finds the shortest path between nodes in a weighted graph. It maintains a set of vertices whose shortest distance from the source node is already known. At each step, it selects the vertex with the smallest known distance and updates the distances to its adjacent vertices if a shorter path is found.</p>
    <pre><code class="language-csharp">
using System;
using System.Collections.Generic;

public class Graph {
    private int V; // Number of vertices
    private List&lt;Tuple<int, int>>[] adj; // Adjacency list with edge weights

    public Graph(int v) {
        V = v;
        adj = new List&lt;Tuple<int, int>>[v];
        for (int i = 0; i < v; ++i) {
            adj[i] = new List&lt;Tuple<int, int>>();
        }
    }

    public void AddEdge(int u, int v, int weight) {
        adj[u].Add(new Tuple<int, int>(v, weight));
        adj[v].Add(new Tuple<int, int>(u, weight)); // For undirected graph
    }

    public void Dijkstra(int source) {
        int[] dist = new int[V];
        bool[] visited = new bool[V];

        for (int i = 0; i < V; ++i) {
            dist[i] = int.MaxValue;
            visited[i] = false;
        }

        dist[source] = 0;

        for (int count = 0; count < V - 1; ++count) {
            int u = MinDistance(dist, visited);
            visited[u] = true;

            foreach (var edge in adj[u]) {
                int v = edge.Item1;
                int weight = edge.Item2;
                if (!visited[v] && dist[u] != int.MaxValue && dist[u] + weight < dist[v]) {
                    dist[v] = dist[u] + weight;
                }
            }
        }

        PrintSolution(dist);
    }

    private int MinDistance(int[] dist, bool[] visited) {
        int min = int.MaxValue, minIndex = -1;

        for (int v = 0; v < V; ++v) {
            if (!visited[v] && dist[v] <= min) {
                min = dist[v];
                minIndex = v;
            }
        }

        return minIndex;
    }

    private void PrintSolution(int[] dist) {
        Console.WriteLine("Vertex \t\t Distance from Source");
        for (int i = 0; i < V; ++i) {
            Console.WriteLine(i + " \t\t " + dist[i]);
        }
    }
}

class Program {
    static void Main(string[] args) {
        Graph g = new Graph(9);
        g.AddEdge(0, 1, 4);
        g.AddEdge(0, 7, 8);
        g.AddEdge(1, 2, 8);
        g.AddEdge(1, 7, 11);
        g.AddEdge(2, 3, 7);
        g.AddEdge(2, 8, 2);
        g.AddEdge(2, 5, 4);
        g.AddEdge(3, 4, 9);
        g.AddEdge(3, 5, 14);
        g.AddEdge(4, 5, 10);
        g.AddEdge(5, 6, 2);
        g.AddEdge(6, 7, 1);
        g.AddEdge(6, 8, 6);
        g.AddEdge(7, 8, 7);

        Console.WriteLine("Dijkstra's Algorithm:");
        g.Dijkstra(0);
    }
}
    </code></pre>
</div>
</div>
</body>

</html>
